import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';
import { SecretsGuard } from './secretsGuard';
import { EnvironmentValidator } from './environmentValidator';
import { ConfigUtils } from './configUtils';
import { GitCommitHookConfig } from '../types/environment';
import { spawn } from 'child_process';

export class GitHookManager {
	/**
	 * Install pre-commit hook that blocks commits with sensitive data
	 */
	static async installHook(workspacePath: string): Promise<void> {
		const gitHooksPath = path.join(workspacePath, '.git', 'hooks');
		const hookPath = path.join(gitHooksPath, 'pre-commit');

		// Ensure .git/hooks directory exists
		if (!fs.existsSync(gitHooksPath)) {
			throw new Error('Git hooks directory not found. Make sure this is a Git repository.');
		}

		// Create the hook script
		const hookScript = this.generateHookScript();

		// Make sure hook is executable
		try {
			await fs.promises.writeFile(hookPath, hookScript, { mode: 0o755 });
			vscode.window.showInformationMessage('âœ… dotenvy pre-commit hook installed successfully!');
		} catch (error) {
			throw new Error(`Failed to install hook: ${error}`);
		}
	}

	/**
	 * Remove pre-commit hook
	 */
	static async removeHook(workspacePath: string): Promise<void> {
		const hookPath = path.join(workspacePath, '.git', 'hooks', 'pre-commit');

		try {
			if (fs.existsSync(hookPath)) {
				await fs.promises.unlink(hookPath);
				vscode.window.showInformationMessage('âœ… dotenvy pre-commit hook removed successfully!');
			} else {
				vscode.window.showInformationMessage('No dotenvy hook found to remove.');
			}
		} catch (error) {
			throw new Error(`Failed to remove hook: ${error}`);
		}
	}

	/**
	 * Check if hook is installed
	 */
	static isHookInstalled(workspacePath: string): boolean {
		const hookPath = path.join(workspacePath, '.git', 'hooks', 'pre-commit');
		return fs.existsSync(hookPath);
	}

	/**
	 * Run pre-commit checks on staged files
	 */
	static async runPreCommitChecks(workspacePath: string): Promise<{blocked: boolean, message: string}> {
  const config = await ConfigUtils.readQuickEnvConfig();
		const hookDefaults: GitCommitHookConfig = {
			blockEnvFiles: true,
			blockSecrets: true,
			blockValidationErrors: true
		};
		const hookConfig: GitCommitHookConfig = { ...hookDefaults, ...config?.gitCommitHook };

		const issues: string[] = [];

		try {
			// Get staged files
			const stagedFiles = await this.getStagedFiles(workspacePath);
			const stagedEnvFiles = stagedFiles.filter(file => file.startsWith('.env'));

			// Check 1: Block .env files
			if (hookConfig.blockEnvFiles && stagedEnvFiles.length > 0) {
				issues.push(`ðŸš« Blocked .env files in commit: ${stagedEnvFiles.join(', ')}\n   Use 'git add --intent-to-add' for templates instead.`);
			}

			// Check 2: Scan for secrets in all files
			if (hookConfig.blockSecrets) {
				for (const file of stagedFiles) {
					const secretsCheck = await this.scanFileForSecrets(workspacePath, file);
					if (secretsCheck.length > 0) {
						issues.push(`ðŸš« Secrets detected in ${file}:\n   ${secretsCheck.join(', ')}`);
					}
				}
			}

			// Check 3: Validation errors in .env files
			if (hookConfig.blockValidationErrors && stagedEnvFiles.length > 0) {
				const validationRules = await ConfigUtils.getValidationRules();
				if (validationRules) {
					for (const envFile of stagedEnvFiles) {
						const filePath = path.join(workspacePath, envFile);
						if (fs.existsSync(filePath)) {
							const errors = EnvironmentValidator.validateFile(filePath, validationRules);
							if (errors.length > 0) {
								const errorText = EnvironmentValidator.formatErrors(errors);
								issues.push(`ðŸš« Validation errors in ${envFile}:\n${errorText}`);
							}
						}
					}
				}
			}

		} catch (error) {
			issues.push(`ðŸš« Hook execution error: ${(error as Error).message}`);
		}

		if (issues.length > 0) {
			const customMessage = hookConfig.customMessage || 'dotenvy commit hook prevented this commit due to security concerns.';
			const message = `${customMessage}\n\n${issues.join('\n\n')}\n\nUse 'git commit --no-verify' to bypass (not recommended).`;

			return { blocked: true, message };
		}

		return { blocked: false, message: 'All checks passed!' };
	}

	/**
	 * Generate the pre-commit hook script
	 */
	private static generateHookScript(): string {
		return `#!/bin/sh
# dotenvy pre-commit hook - prevents committing sensitive environment data
# Generated by dotenvy VS Code extension

# Get the workspace root (assuming hook is in .git/hooks/)
WORKSPACE_DIR="$(git rev-parse --show-toplevel)"

# Check if Node.js is available
if ! command -v node >/dev/null 2>&1; then
    echo "WARNING: Node.js not found. Skipping dotenvy checks."
    exit 0
fi

# Try to find and run the dotenvy hook
HOOK_SCRIPT=""
if [ -f "$WORKSPACE_DIR/node_modules/.bin/dotenvy-hook" ]; then
    HOOK_SCRIPT="$WORKSPACE_DIR/node_modules/.bin/dotenvy-hook"
elif command -v dotenvy-hook >/dev/null 2>&1; then
    HOOK_SCRIPT="dotenvy-hook"
else
    echo "WARNING: dotenvy-hook script not found. Install dotenvy globally or run 'npm install' in workspace."
    exit 0
fi

# Run the hook
exec "$HOOK_SCRIPT" "$WORKSPACE_DIR"
`.replace(/\r\n/g, '\n'); // Ensure Unix line endings
	}

	/**
	 * Get list of staged files
	 */
	private static async getStagedFiles(workspacePath: string): Promise<string[]> {
		try {
			const result = await this.execGitCommand(workspacePath, ['diff', '--cached', '--name-only']);
			return result.split('\n').filter(line => line.trim().length > 0);
		} catch {
			return [];
		}
	}

	/**
	 * Execute a git command
	 */
	private static async execGitCommand(cwd: string, args: string[]): Promise<string> {
		return new Promise((resolve, reject) => {
			const git = spawn('git', args, { cwd });

			let stdout = '';
			let stderr = '';

			git.stdout.on('data', (data: Buffer) => {
				stdout += data.toString();
			});

			git.stderr.on('data', (data: Buffer) => {
				stderr += data.toString();
			});

			git.on('close', (code: number | null) => {
				if (code === 0) {
					resolve(stdout);
				} else {
					reject(new Error(`git command failed: ${stderr}`));
				}
			});

			git.on('error', (error: Error) => {
				reject(error);
			});
		});
	}

	/**
	 * Scan a file for secrets
	 */
	private static async scanFileForSecrets(workspacePath: string, filePath: string): Promise<string[]> {
		try {
			const fullPath = path.join(workspacePath, filePath);
			const stats = await fs.promises.stat(fullPath);

			// Skip if file is too large (>1MB) or binary
			if (stats.size > 1024 * 1024) {
				return [];
			}

			const content = await fs.promises.readFile(fullPath, 'utf8');

			// Skip binary files
			if (content.includes('\0')) {
				return [];
			}

			return SecretsGuard.checkFile(fullPath);
		} catch {
			return [];
		}
	}
}
